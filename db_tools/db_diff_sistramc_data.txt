# WARNING: Objects in server1.sistramc_data but not in server1.sistramc_data_orig:
#    PROCEDURE: sp_resumen_estados

DROP PROCEDURE IF EXISTS `sp_resumen_estados`;
DELIMITER $$
CREATE PROCEDURE `sp_resumen_estados`()
BEGIN
select d.nestado as estado, count(d.nestado) as total from (
select 
    case 
		when (od.estado = 104 and (o.factura is null or trim(o.factura) = "")) then 1004
	else
		od.estado
	end as nestado	
from orden o
join orden_detalle od on o.id = od.orden 
    and od.id = (select max(od1.id) from orden_detalle od1 where od1.orden = o.id)
) d
group by d.nestado
order by 2 desc;
END$$
DELIMITER ;

#    PROCEDURE: sp_test_temp_table
DROP PROCEDURE IF EXISTS `sp_test_temp_table`;
DELIMITER $$
CREATE  PROCEDURE `sp_test_temp_table`(
	in ar varchar(400)
)
BEGIN
  declare pos int;           -- Keeping track of the next item's position
  declare item varchar(100); -- A single item of the input
  declare breaker int;       -- Safeguard for while loop 

  -- The string must end with the delimiter
  if right(ar, 1) <> '.' then
     set ar = concat(ar, ',');
  end if;

  DROP TABLE IF EXISTS tbl_search_tmp;
  CREATE TEMPORARY TABLE tbl_search_tmp ( search varchar(100) );
  set breaker = 0;

  while (breaker < 2000) && (length(ar) > 1) do
     -- Iterate looking for the delimiter, add rows to temporary table.
     set breaker = breaker + 1;
     set pos = INSTR(ar, ',');
     set item = LEFT(ar, pos - 1);
     set ar = substring(ar, pos + 1);
     insert into tbl_search_tmp values(item);
  end while;
  
  select * from tbl_search_tmp;
  
  drop table tbl_search_tmp;
  
END$$
DELIMITER ;

#    PROCEDURE: sp_resumen_estados_1

DROP PROCEDURE IF EXISTS `sp_resumen_estados_1`;
DELIMITER $$
CREATE  PROCEDURE `sp_resumen_estados_1`()
BEGIN

	declare v_finished int;
    
    declare v_estado int;
    declare v_total int;

	declare ord_nuevas int;
    declare ord_reabiertas int;
    declare ord_pendientes int;
    declare ord_presupuestadas int;
    declare ord_aprobadas int;
    declare ord_iniciadas int;
    declare ord_terminadas int;
    declare ord_facturadas int;
    declare ord_sin_facturar int;
    
    declare estados_cursor cursor for

		(select d.nestado as estado, count(d.nestado) as total from (
		select 
			if (od.estado = 104, if (o.factura is null or trim(o.factura) = "", 1004, 2004), od.estado) as nestado
		from orden o
		join orden_detalle od on o.id = od.orden 
			and od.id = (select max(od1.id) from orden_detalle od1 where od1.orden = o.id)
		) d
		group by d.nestado
		order by 2 desc);
        
	declare continue handler
		for not found set v_finished = 1;
        
	open estados_cursor;
    
    get_estado: loop
	
    fetch estados_cursor into v_estado, v_total;
    
    if v_finished = 1 then
    leave get_estado;
    end if;
    
    case v_estado
		when 100 then set ord_nuevas = v_total;
        when 101 then set ord_presupuestadas = v_total;
        when 102 then set ord_aprobadas = v_total;
        when 103 then set ord_iniciadas = v_total;
        when 106 then set ord_reabiertas = v_total;
        when 1004 then set ord_sin_facturar = v_total;
        when 2004 then set ord_facturadas = v_total;
	else begin end;
	end case; 
    
    set ord_pendientes = ord_nuevas + ord_reabiertas;
    set ord_terminadas = ord_facturadas + ord_sin_facturar;
    
    -- set ord_pendientes = v_estado;
    -- set ord_facturadas = v_total;
    
    end loop get_estado;
    
    close estados_cursor;
    
    select 
		ord_nuevas, ord_reabiertas, ord_pendientes,
        ord_presupuestadas, ord_aprobadas, ord_iniciadas,
        ord_terminadas, ord_facturadas, ord_sin_facturar;
    
END$$
DELIMITER ;


# Comparing `sistramc_data_orig`.`sp_orden_select-range` to `sistramc_data`.`sp_orden_select-range`   [FAIL]
# Transformation for --changes-for=server1:
#

DROP PROCEDURE IF EXISTS `sp_orden_select-range`;
DELIMITER //
CREATE PROCEDURE `sp_orden_select-range` (
	in p_startpos int, 
	in p_count int,
	in p_filter_field varchar(50),
	in p_filter_value int,
	in p_filter_text text,
	in p_user_type int,
	in p_user_id int,
	inout o_count int
) CONTAINS SQL SQL SECURITY DEFINER BEGIN
	declare pos int;           -- Keeping track of the next item's position
    declare item varchar(100); -- A single item of the input
    declare breaker int;       -- Safeguard for while loop 

	set @startpos = p_startpos;
	set @count = p_count;
	set @filter_field = p_filter_field;
	set @filter_value = p_filter_value;
	set @filtered = false;
	set @q = o_count;
	set @filter_text_tmp = p_filter_text;
	set @user_type = p_user_type;
	set @user_id = p_user_id;
    
	-- The string must end with the delimiter
	if right(@filter_text_tmp, 1) <> ',' then
		set @filter_text_tmp = concat(@filter_text_tmp, ',');
	end if;

    if @user_type = 1 then
		set @stmnt_p  = "select max(p1.id) from vw_presupuesto p1 \n            where p1.orden = o.id and p1.p_tipo = 2";
        set @stmnt_od = "select max(od1.id) from vw_orden_detalle od1 \n\t\t\twhere od1.orden = o.id and (od1.estado not in (101,102,202) or \n\t\t\t\t(od1.estado = 101 and od1.tipo = 3) or \n                (od1.estado in (102, 202) and od1.tipo = 1))";
	elseif @user_type = 2 then
		set @stmnt_p = "select max(p1.id) from vw_presupuesto p1 \n\t\t\twhere p1.orden = o.id and p1.p_tipo = 1";
        set @stmnt_od = "select max(od1.id) from vw_orden_detalle od1 \n\t\t\twhere od1.orden = o.id and (od1.estado not in (101,102,202) or \n\t\t\t\t(od1.estado = 101 and od1.tipo = 2) or \n                (od1.estado in (102, 202) and od1.tipo = 3))";
	else
		set @stmnt_p = "select max(p1.id) from vw_presupuesto p1 where p1.orden = o.id";
        set @stmnt_od = "select max(od1.id) from vw_orden_detalle od1 where od1.orden = o.id";
	end if;
	
	if @q = 1 then
		set @stmnt = replace(replace("\n\t\t\tselect \n\t\t\t\tcount(*) into @q \n\t\t\tfrom \n\t\t\t\torden o\n            join \n\t\t\t\tvehiculo v on v.id = o.vehiculo \n\t\t\tjoin \n\t\t\t\tcliente c on c.id = o.cliente\n\t\t\tjoin \n\t\t\t\ttaller t on t.id = o.taller\n\t\t\tjoin \n\t\t\t\tmarca m on m.id = v.marca\n\t\t\tjoin \n\t\t\t\tmodelo d on d.id = v.modelo\n\t\t\tjoin \n\t\t\t\tzona z on z.id = o.zona\n\t\t\tleft outer join \n\t\t\t\tvw_orden_detalle od1 on od1.orden = o.id and od1.estado = 100\n\t\t\tleft outer join \n\t\t\t\tvw_orden_detalle od on od.orden = o.id and od.id = ($stmnt_od$)\n\t\t\tleft outer join \n\t\t\t\tvw_presupuesto p on p.orden = o.id and p.id = ($stmnt_p$)\n\t\t\tleft outer join \n\t\t\t\testado e on e.id = od.estado", 
			"$stmnt_p$", @stmnt_p), "$stmnt_od$", @stmnt_od);
	else
		set @stmnt = replace(replace("\n\t\t\tselect \n\t\t\t\to.*, \n                m.marca as orden_marca, \n                d.modelo as orden_modelo, \n                t.nombre as orden_taller,\n                e.descripcion as orden_estado, \n                c.nombre as orden_cliente,\n                v.dominio as orden_dominio,\n                od.id as od_id,\n                od.estado as od_estado,\n                case p.estado\n\t\t\t\t\twhen 1 then concat(p.id, ' - Pendiente')\n                    when 2 then concat(p.id, ' - Aprobado')\n                    when 3 then concat(p.id, ' - Rechazado')\n\t\t\t\telse \n\t\t\t\t\t'Indefinido'\n\t\t\t\tend as presupuesto,\n                p.id as p_id,\n                p.p_tipo,\n                cast(od1.fecha as date) as fecha,\n                cast(od1.fecha as time) as hora,\n                ifnull(`fn_orden_total_repuestos`(o.id), 0) + \n\t\t\t\t\tifnull(`fn_orden_total_mano_obra`(o.id, if(@user_type = 2,2,1)), 0) as total_orden\n\t\t\tfrom \n\t\t\t\torden o\n\t\t\tjoin \n\t\t\t\tvehiculo v on v.id = o.vehiculo\n            join \n\t\t\t\tcliente c on c.id = o.cliente\n            join \n\t\t\t\ttaller t on t.id = o.taller\n            join \n\t\t\t\tmarca m on m.id = v.marca\n            join \n\t\t\t\tmodelo d on d.id = v.modelo\n            join \n\t\t\t\tzona z on z.id = o.zona\n            left outer join \n\t\t\t\tvw_orden_detalle od1 on od1.orden = o.id and od1.estado = 100\n            left outer join \n\t\t\t\tvw_orden_detalle od on od.orden = o.id and od.id = ($stmnt_od$)\n\t\t\tleft outer join \n\t\t\t\tvw_presupuesto p on p.orden = o.id and p.id = ($stmnt_p$)\n\t\t\tleft outer join estado e on e.id = od.estado", 
		"$stmnt_p$", @stmnt_p), "$stmnt_od$", @stmnt_od);			
	end if;

	set @where_clause = "(o.referencia like '%$ftext$%' or \n\t\t\t\t m.marca like '%$ftext$%' or \n\t\t\t\t d.modelo like '%$ftext$%' or \n\t\t\t\t t.nombre like '%$ftext$%' or \n\t\t\t\t c.nombre like '%$ftext$%'or \n\t\t\t\t e.descripcion like '%$ftext$%' or \n\t\t\t\t v.dominio like '%$ftext$%' or \n\t\t\t\t z.nombre like '%$ftext$%' or \n\t\t\t\t o.interno like '%$ftext$%' or \n\t\t\t\t case p.estado \n\t\t\t\t\twhen 1 then 'Pendiente' \n\t\t\t\t\twhen 2 then 'Aprobado'\n\t\t\t\t\twhen 3 then 'Rechazado'\n\t\t\t\t else \n\t\t\t\t\t'Indefinido'\n\t\t\t\t end like '%$ftext$%' or \n\t\t\t\t cast(o.id as char(100)) like '%$ftext$%' or \n\t\t\t\t cast(p.id as char(100)) like '%$ftext$%' or \n\t\t\t\t o.factura like '%$ftext$%' or \n\t\t\t\t o.observaciones like '%$ftext$%' or \n\t\t\t\t cast(od1.fecha as char(100)) like '%$ftext$%' or \n\t\t\t\t if ((o.factura is null or trim(o.factura) = '') and (od.estado = 104 or od.estado = 105), \n\t\t\t\t\t'SIN FACTURAR', o.factura) like '%$ftext$%')";    

	set breaker = 0;

	while (breaker < 3) && (length(@filter_text_tmp) > 1) do
		-- Iterate looking for the delimiter, add rows to temporary table.
		set pos = INSTR(@filter_text_tmp, ',');
		set item = LEFT(@filter_text_tmp, pos - 1);
		set @filter_text_tmp = substring(@filter_text_tmp, pos + 1);
		case breaker
			when 0 then set @filter_text   = item;
            when 1 then set @filter_text_1 = item;
            when 2 then set @filter_text_2 = item;
		else
			set @filter_text = @filter_text_tmp;
		end case;
		set breaker = breaker + 1;
	end while;

    if @filter_text <> "" then
		set @where_clause_stmnt = replace(@where_clause, "$ftext$", @filter_text);
        if @filter_text_1 <> "" then
			set @where_clause_stmnt = concat(@where_clause_stmnt, " and ", replace(@where_clause, "$ftext$", @filter_text_1));
            if @filter_text_2 <> "" then
				set @where_clause_stmnt = concat(@where_clause_stmnt, " and ", replace(@where_clause, "$ftext$", @filter_text_2));
			end if;
        end if;
    end if;
    
	if @filter_text <> "" then
		if @user_type = 1 then
			set @stmnt = replace(concat(@stmnt, " where c.id in (select cliente from usuario_cliente where usuario = $fuser$) and ", 
                @where_clause_stmnt), "$fuser$", @user_id);
		elseif @user_type = 2 then
			set @stmnt = replace(concat(@stmnt, " where\tt.id in (select taller from usuario_taller where usuario = $fuser$) and ",
				@where_clause_stmnt), "$fuser$", @user_id);
		else
			set @stmnt = concat(@stmnt, " where ", @where_clause_stmnt);
		end if;

	elseif @filter_field != "" and @filter_value != -1 then
		set @filtered = true;
		if @user_type = 1 then
			set @stmnt = concat(@stmnt, replace(" where \n\t\t\t\tc.id in (select cliente from usuario_cliente where usuario = $fuser$) and ", 
					"$fuser$", @user_id), @filter_field, " = ?");
		elseif @user_type = 2 then
			set @stmnt = concat(@stmnt, replace(" where \n\t\t\t\tt.id in (select taller from usuario_taller where usuario = $fuser$) and ", 
					"$fuser$", @user_id), @filter_field, " = ?");
		else
			set @stmnt = concat(@stmnt, " where ", @filter_field, " = ?");
		end if;
	else
		if @user_type = 1 then
			set @stmnt = concat(@stmnt, replace(" where \n\t\t\t\tc.id in (select cliente from usuario_cliente where usuario = $fuser$)", 
					"$fuser$", @user_id));
		elseif @user_type = 2 then
			set @stmnt = concat(@stmnt, replace(" where \n\t\t\t\tt.id in (select taller from usuario_taller where usuario = $fuser$)", 
					"$fuser$", @user_id));
		end if;		
	end if;

	if o_count != 1 then
		set @stmnt = concat(@stmnt, " group by o.id order by o.id desc limit ?,?;");
		prepare new_stmnt_2 from @stmnt;
		if @filtered then
			execute new_stmnt_2 using @filter_value, @startpos, @count;
		else
			execute new_stmnt_2 using @startpos, @count;
		end if;
		deallocate prepare new_stmnt_2;
	else
		prepare new_stmnt_2 from @stmnt;
		if @filtered then
			execute new_stmnt_2 using @filter_value;
		else
			execute new_stmnt_2;
		end if;
		deallocate prepare new_stmnt_2;
	end if;

	select @q into o_count;
END//
DELIMITER ;


